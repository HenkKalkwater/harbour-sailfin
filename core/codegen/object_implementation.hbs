{{className}}::{{className}}() {}


{{className}} {{className}}::fromJson(QJsonObject source) {
	
	{{className}} instance;
	instance.setFromJson(source);
	return instance;
}


void {{className}}::setFromJson(QJsonObject source) {

	{{#each properties as |property|}}
	{{property.memberName}} = {{supportNamespace}}::fromJsonValue<{{property.typeNameWithQualifiers}}>(source["{{property.originalName}}"]);

	{{/each}}

}
	
QJsonObject {{className}}::toJson() {
	QJsonObject result;

	{{#each properties as |property|}}
	result["{{property.originalName}}"] = {{supportNamespace}}::toJsonValue<{{property.typeNameWithQualifiers}}>({{property.memberName}});

	{{/each}}

	return result;
}


{{#each properties as |property|}}
{{property.typeNameWithQualifiers}} {{className}}::{{property.name}}() const { return {{property.memberName}}; }

void {{className}}::set{{property.writeName}}({{property.typeNameWithQualifiers}} new{{property.writeName}}) {
	
	{{property.memberName}} = new{{property.writeName}};
}

{{#if property.isNullable}}
bool {{className}}::is{{property.writeName}}Null() const {
	return {{property.nullableCheck}};
}

void {{className}}::setNull() {
	{{property.nullableSetter}};
}
{{/each}}

} // NS DTO

namespace Support {

using {{className}} = Jellyfin::DTO::{{className}};

template <>

{{className}} fromJsonValue<{{className}}>(const QJsonValue &source) {
	if (!source.isObject()) throw new ParseException("Expected JSON Object");
	return {{className}}::fromJson(source.toObject());
}
