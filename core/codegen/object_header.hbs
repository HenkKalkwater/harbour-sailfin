{{#each userImports as |userClass|}}
{{#if userClass != className}}
class {{className}};

{{/if}}
{{/each}}

class {{className}} {
public:
	explicit {{className}}();
	static {{className}} fromJson(QJsonObject source);
	void setFromJson(QJsonObject source);
	QJsonObject toJson();
	
	// Properties

{{#each properties as |p|}}
{{#if p.description.length > 0}}
	/**
	 * @brief {{p.description}}

	 */
{{/if}}

	{{p.typeNameWithQualifiers}} {{p.name}}() const;

{{#if p.description.length > 0}}
	/**
	* @brief {{p.description}}

	*/
{{/if}}

	void set{{p.writeName}}({{p.typeNameWithQualifiers}} new{{p.writeName}});

{{#if p.isNullable}}
	bool is{{p.writeName}}Null() const;
	void set{{p.writeName}}Null();
{{/if}}
{{/each}}

protected:

{{#each properties as |p|}}
{{#if p.defaultInitializer.length > 0}}
	{{p.typeNameWithQualifiers}} {{p.memberName}} = {{p.defaultInitializer}};
{{else}}
	{{p.typeNameWithQualifiers}} {{p.memberName}};
{{/if}}

{{/each}}
};

} // NS DTO

namespace Support {

using {{className}} = Jellyfin::DTO::{{className}};

template <>

{{className}} fromJsonValue<{{className}}>(const QJsonValue &source) {
	if (!source.isObject()) throw new ParseException("Expected JSON Object");
	return {{className}}::fromJson(source.toObject());
}
